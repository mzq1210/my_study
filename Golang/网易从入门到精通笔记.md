Gopath 项目路径

```go
// 查看go的各种配置
go env

// go程序都需要编译，如果项目文件夹只有一层且就在src文件下，直接编译即可(注意编译指定到目录，不能指定到文件)
go build hello
// 如果项目是多层目录，则需要补全路径，注意src省略(注意编译指定到目录，不能指定到文件)
go build github.com/hello
// 默认情况下编译的二进制文件会放在项目根目录下，如果需要指定编译位置，hellotest是可执行文件的名字，可自定义
go build -o bin/hellotest github.com/hello

// 无需编译，直接运行，注意这里需要加src
go run src/github.com/hello

// 直接安装二进制文件到bin目录，与go build -o bin/*作用一样
go install github.com/hello

// 编译之后会根据当前系统生成可执行文件，直接运行即可
./hello

// 单元测试
go test

// 格式化源代码，后面路径规则与build类似
go fmt github.com/hello

// 占位符：%d代表数字、%s代表字符串、%f代表浮点数、%v万能符,函数不能用万能符%v，而是用%T
fmt.Printf("a=%d b=%s", a, b)

// 批量定义常量如果没有设置常量的类型和值，则自动继承上一个常量的类型和值
const(
	a=100
  b
)

// iota表示每隔一行自增，初始值为0，每次+1，则b=1，注意：iota是有作用域的，两个函数中的iota都是从0开始
const(
	a=iota
  b
  c
)

// iota每隔一行自增什么意思，如下：a=0，f隔行自增之后为5
const(
	a=iota
  b
  c
  d=8
  e
  f=iota
)

// 快捷定义变量
// 正常情况下定义一个变量是：
var a int
a=100
// 或
var a int = 100

// := 推导则可以快速定义变量,它可以根据值自动选择类型，相当于上面的两行，注意 := 只有在第一次定义变量的时候有效
a:=100
// 也可以定义多个
a,b := 100, 'test'

// package包，变量或者函数首字母大写可以通过外部访问，小写则为私有变量或方法，比如
fmt.Printf("a=%d b=%s", a, b)

// 英文字符串计算长度可直接用len()，因为其底层占1个byte字节，而中文字符串每个汉字占3个字节无法直接用len()计算会出现误差，因为len()计算的是字节数所以需要把中文字符转化为rune类型，rune类型进行切片后再使用len()计算长度。rune类型下面有介绍
// 注意:单引号代表字符，双引号代表字符串，中文不能使用单引号
str := "中"
fmt.Printf("a=%d\n", len(str))  // 3
var runeSlice []rune
runeSlice = []rune(str)
fmt.Printf("a=%d", len(runeSlice)) // 1

// 定时器的使用？？？？？？？？
time.Tick(1*time.Second)

// 时间格式化，这里一定要写2006-01-02 15:04:05，不然格式化的时间不准
now := time.Now()
timeStr := now.Format("2006-01-02 15:04:05") 
fmt.Printf("a=%v", timeStr)

// if可以在结构体上定义变量，但这个变量的生命周期和作用域只在if结构体中，if结构体结束变量销毁
if num := 10; num % 2 == 0 {
  fmt.Printf("num=%v", num)
}else{
  fmt.Printf("num=%v", num)
}
// 这里就会报错
fmt.Printf("num=%v", num)

// for循环可以简写
i :=1
for i <=10 {
  i=i+2
}
// 也可以多个变量循环
for no, i := 10,1;i<=10 && no<=19; i,no = i+1, no+1 {
    fmt.Printf("i=%v no=%v", i, no)
}

// swich 多个case如果是同样的逻辑可以放到一起，且case也可以使用表达式
// fallthrough 放在case结构体中的最后一行，独占一行，意思是接着执行下面的case

// 函数，多个参数(如果连着两个参数的类型一样，可以只写一个类型)，多个返回值
func calc(a, b int)(sum int, sub int){
  sum = a + b
  sub = a - b
  return
}
// _代表省略，如果只对两数之和感兴趣，差就不需要接收变量了
sum, _ := calc(100, 200)

// 一次传零个或多个参数，这个时候b是一个数组
func calc(b ...int) int {
  sum := 0
  for i := 0,1;i < len(b); i++ {
    sum = sum + b[i]
	}
  return sum
}
sum := calc(100, 200, 300, 400)

// 函数可以赋值给一个变量，注意赋值的时候这个变量接收的是这个函数体，函数是没有运行的，如果要调用这个变量，可直接使用变量加上括号，括号里面传参，同样，匿名函数也可以赋值给一个变量
// 函数也可以作为一个参数传进去
func sum(a,b int) int {
  return a+b
}

func calc(a, b, op func(int int) int ) int {
  return op(a,b)
}
sum := calc(100, 200, sum)
```

> **1.byte类型**是**uint8的别名**，表示一个字节，
> **2.rune类型**是Go语言中的一个基本类型，其实就是一个**int32的别名**，主要用于表示一个字符类型大于一个字节小于等于四个字节的情况，特别是**中文字符**，中文格式是utf-8.

>九九乘法表
```go
//思想 为什么把i放在后面，因为后面的数是固定的，符合外层for的规律
// 第一行， j*i 1x1
// 第二行， j*i 1x1
// 第三行， j*i 1x1 ……
for i := 1;i < 10; i++ {
  for j := 1;j <=i; j++ {
    fmt.Printf("%v * %v = %v", j, i, j*i)
  }
  fmt.Printf("\n")
}
```
> 插入排序
```go
//思想：就像摸牌，先选出一张牌无论它大小，然后每次再掀一张与手中的所有牌进行对比插入。所以0作为首牌，i从1开始，i的牌给j，j与j-1比较，因为要和手中的所有牌对比，所以是j--，j为什么大于0？因为0号就是最小的牌，不能继续比下去了
// 第一次， a[1]和a[0]比较,小的插在前面
// 第二次， a[1]和a[2~n]之后所有的数比较,选出小的
// 第三次， 同上……
func insert_sort(a [8]int) [8]int {
	for i := 1; i < len(a); i++ {
		for j := i; j > 0; j-- {
			if a[j] < a[j-1] {
				a[j], a[j-1] = a[j-1], a[j]
      }else{
        break
      }
		}
	}
	return a
}
```

>选择排序

```go
//思想：每次都选出最小的放在前面，是i和j比较
// 第一次， a[0]和a[1~n]之后所有的数比较,选出最小的
// 第二次， a[1]和a[2~n]之后所有的数比较,选出小的
// 第三次， 同上……
func insert_sort(a [8]int) [8]int {
	for i := 0; i < len(a); i++ {
		for j := i+1; j < len(a); j++ {
			if a[j] < a[i] {
				a[j], a[i] = a[i], a[j]
			}
		}
	}
	return a
}
```
> 冒炮排序
```go
//思想：从小到大排序，是j和j+1比较，i为什么是1，是为了j的判断条件少比一次，因为如果不减1,j+1会溢出。注意和插入排序的区别，插入排序的每一轮都是首位与除了它之外的所有下标比较，而冒泡每一轮都是相邻的下标前后比较
// 第一次， 从头开始比，最大的在最后
// 第二次， 从头开始比，大的向后移
// 第三次， 同上……
func insert_sort(a [8]int) [8]int {
	for i := 1; i < len(a); i++ {
		for j := 0; j < len(a)-i; j++ {
			if a[j] > a[j+1] {
				a[j], a[j+1] = a[j+1], a[j]
			}
		}
	}
	return a
}
```


> defer 函数中的defer表示定义一条语句，这条语句通常是函数调用，主要用来释放资源，它通常是在函数返回值返回之前调用，相当于放在甘薯体内的最后一行执行，如果是多个defer呢？谁在最下面先执行谁，即先打印v3后v2

```go
func calc() {
	defer fmt.Printf("hello")
  defer fmt.Printf("hello v2")
  defer fmt.Printf("hello v3")
  fmt.Printf("aaaa")
  fmt.Printf("bbbb")
}

//另一种情况，下面打印的是什么？正确的应该是 1000,1，因为虽然defer是最后执行，但defer定义的时候已经确定了i的值，不会改变了，下面的操作对i不影响
func calc() {
  var i int = 0
	defer fmt.Printf(i)
  i = 1000
  fmt.Printf(i)
}

// 还有一种情况,下面打印的是什么？正确的应该是 1000,1000，因为虽然defer后面是个匿名函数，这个函数里面的i不是传进去的，而i计算的时候值已经改变，所以是1000，注意匿名函数最后的括号表示立即执行，跟js的匿名函数差不多
func calc() {
	var i int = 0
  defer fun(){
    fmt.Printf(i)
  }()
  i = 1000
  fmt.Printf(i)
}
```

> close:主要用于关闭channel
>
> len:用于计算长度，比如字符串、数组、切片、map、channel
>
> new:用于分配内存，主要用于分配值类型，比如int、struct，返回指针
>
> make:用于分配内存，主要用于分配引用类型，比如切片、map、channel
>
> append:用于追加元素到数组或切片
>
> panic和recover:用于处理异常

> 特别要注意go中的除数运算与其他语言不同，例如下面的例子，其他语言会得出2.5，而go得出的是2，因为go是静态语言，a定义的时候是整形，那么结果也是一个整形，除非把a从整形转换为浮点型

```go
func main () {
	var a int = 52
	b := a/10
	fmt.Printf("b=%d", b)
} 
```

### 函数

```go
func Adder() func(int)int {
	var x int
	return func(d int)int {
		x += d
		return x
	}
}

// 这里f的类型取决于Adder是否加了括号，因为加上括号就相当于执行了启动，启动就有返回值，如果没有加括号f的类型就是整个结构体，如果加了括号f就是函数运行之后的返回值，即匿名函数
f := Adder()
ret := f(1)
fmt.Printf("f(1):ret=%d\n", ret)
ret = f(20)
fmt.Printf("f(20):ret=%d\n", ret)
ret = f(300)
fmt.Printf("f(100):ret=%d\n", ret)
```

### 闭包
> 概念：**指有权访问另一个函数作用域中变量的函数**。简单理解就是 ，**一个作用域可以访问另外一个函数内部的局部变量**。
> 作用：**延伸变量的作用范围。**

使用js举个例子
```js
/*需求分析
打车起步价13(3公里内),  之后每多一公里增加 5块钱.  用户输入公里数就可以计算打车价格
如果有拥堵情况,总价格多收取10块钱拥堵费*/
 
var car = (function() {
     var start = 13; // 起步价  局部变量
     var total = 0; // 总价  局部变量
     return {
       // 正常的总价
       price: function(n) {
         if (n <= 3) {
           total = start;
         } else {
           total = start + (n - 3) * 5
         }
         return total;
       },
       // 拥堵之后的费用
       yd: function(flag) {
         return flag ? total + 10 : total;
       }
	}
 })();
console.log(car.price(5)); // 23
console.log(car.yd(true)); // 33
```

### 数组

> 1.缺点：长度一旦定义就无法改变，即使[...]也一样，长度在它赋值的时候就已经确定了
>
> 2.当数组作为参数传入到函数中时，也是把那个数据拷贝了一份，修改参数不会改变原数组的值，如果原数组数据过大，则很影响效率

```go
// 产生一个随机数种子，为什么？？？？？？
rand.Seed(time.Now().Unix())
// 产生一个0~999的随机数
rand.Intn(1000) 
```

### 切片

> 1.是基于数组类型做的一层封装，可以自动扩容，意思是切片的底层也是数组。注意定义的时候与数组的区别，[]中有数字就是数组，没有数字就是切换。
>
> 2.切片是左开右闭原则，比如[1:3]是从下标1~2，不包括3
>
> 3.修改切片中的值会对原数组也进行修改，说明切片是对数组的引用，而不是复制

```go
// make创建切片，理解长度（前5）和容量（后10），长度代表目前占用的数组空间，容量代表数组总的空间数
var a []int
a = make([]int, 5, 10)
// 但是如果直接设置a[5]是会报错的，因为数组不会自动扩容，需要用append进行扩容
a[5] = 100           //错误
a = append(a, 100)   //正确

//如果是这种情况呢？长度和容量分别是多少？
a := [...]int{0,1,2,3,4,5,6,7}
b = a[1:3]
// 答案是 长度2 容量7，长度好理解为什么容量是7，因为切片是对数组的引用，所以切片分割的时候会把切下来的部分作为长度，而会把从起点开始切割到原数组的最后作为切片的默认容量
// 切片之后再切片呢？？？结果是1~7，因为第一次切片之后，原切片的长度是1~2，容量是1~7，而第二次切片是在第一次切片的容量基础上切的，所以是1~7.注意：切的是第一次切片的容量而不是长度
b = b[:cap(b)]
```

> 扩容
>
> 1.扩容到最大的时候继续append会怎么样呢？会继续扩容，规则是目前的容量基础上翻倍扩容，也就是会变为20，接下来是40,80,160
>
> 2.



并发课程里有 chan(通道) 和 锁

[chan的解释](https://www.cnblogs.com/xinliangcoder/p/11286801.html)：chan 可以理解为队列，先进先出。

grom就相当于yii框架中的ORM数据库查询























