Gopath 项目路径

```go
// 查看go的各种配置
go env

// go程序都需要编译，如果项目文件夹只有一层且就在src文件下，直接编译即可(注意编译指定到目录，不能指定到文件)
go build hello
// 如果项目是多层目录，则需要补全路径，注意src省略(注意编译指定到目录，不能指定到文件)
go build github.com/hello
// 默认情况下编译的二进制文件会放在项目根目录下，如果需要指定编译位置，hellotest是可执行文件的名字，可自定义
go build -o bin/hellotest github.com/hello

// 无需编译，直接运行，注意这里需要加src
go run src/github.com/hello

// 直接安装二进制文件到bin目录，与go build -o bin/*作用一样
go install github.com/hello

// 编译之后会根据当前系统生成可执行文件，直接运行即可
./hello

// 单元测试
go test

// 格式化源代码，后面路径规则与build类似
go fmt github.com/hello

// 占位符：%d代表数字、%s代表字符串、%f代表浮点数、%v万能符,函数不能用万能符%v，而是用%T
fmt.Printf("a=%d b=%s", a, b)

// 批量定义常量如果没有设置常量的类型和值，则自动继承上一个常量的类型和值
const(
	a=100
  b
)

// iota表示每隔一行自增，初始值为0，每次+1，则b=1，注意：iota是有作用域的，两个函数中的iota都是从0开始
const(
	a=iota
  b
  c
)

// iota每隔一行自增什么意思，如下：a=0，f隔行自增之后为5
const(
	a=iota
  b
  c
  d=8
  e
  f=iota
)

// 快捷定义变量
// 正常情况下定义一个变量是：
var a int
a=100
// 或
var a int = 100

// := 推导则可以快速定义变量,它可以根据值自动选择类型，相当于上面的两行，注意 := 只有在第一次定义变量的时候有效
a:=100
// 也可以定义多个
a,b := 100, 'test'

// package包，变量或者函数首字母大写可以通过外部访问，小写则为私有变量或方法，比如
fmt.Printf("a=%d b=%s", a, b)

// 英文字符串计算长度可直接用len()，因为其底层占1个byte字节，而中文字符串每个汉字占3个字节无法直接用len()计算会出现误差，因为len()计算的是字节数所以需要把中文字符转化为rune类型，rune类型进行切片后再使用len()计算长度。rune类型下面有介绍
// 注意:单引号代表字符，双引号代表字符串，中文不能使用单引号
str := "中"
fmt.Printf("a=%d\n", len(str))  // 3
var runeSlice []rune
runeSlice = []rune(str)
fmt.Printf("a=%d", len(runeSlice)) // 1

// 定时器的使用？？？？？？？？
time.Tick(1*time.Second)

// 时间格式化，这里一定要写2006-01-02 15:04:05，不然格式化的时间不准
now := time.Now()
timeStr := now.Format("2006-01-02 15:04:05") 
fmt.Printf("a=%v", timeStr)

// if可以在结构体上定义变量，但这个变量的生命周期和作用域只在if结构体中，if结构体结束变量销毁
if num := 10; num % 2 == 0 {
  fmt.Printf("num=%v", num)
}else{
  fmt.Printf("num=%v", num)
}
// 这里就会报错
fmt.Printf("num=%v", num)

// for循环可以简写
i :=1
for i <=10 {
  i=i+2
}
// 也可以多个变量循环
for no, i := 10,1;i<=10 && no<=19; i,no = i+1, no+1 {
    fmt.Printf("i=%v no=%v", i, no)
}

// swich 多个case如果是同样的逻辑可以放到一起，且case也可以使用表达式
// fallthrough 放在case结构体中的最后一行，独占一行，意思是接着执行下面的case

// 函数，多个参数(如果连着两个参数的类型一样，可以只写一个类型)，多个返回值
func calc(a, b int)(sum int, sub int){
  sum = a + b
  sub = a - b
  return
}
// _代表省略，如果只对两数之和感兴趣，差就不需要接收变量了
sum, _ := calc(100, 200)

// 一次传零个或多个参数，这个时候b是一个数组
func calc(b ...int) int {
  sum := 0
  for i := 0,1;i < len(b); i++ {
    sum = sum + b[i]
	}
  return sum
}
sum := calc(100, 200, 300, 400)

// 函数可以赋值给一个变量，注意赋值的时候这个变量接收的是这个函数体，函数是没有运行的，如果要调用这个变量，可直接使用变量加上括号，括号里面传参，同样，匿名函数也可以赋值给一个变量
// 函数也可以作为一个参数传进去
func sum(a,b int) int {
  return a+b
}

func calc(a, b, op func(int int) int ) int {
  return op(a,b)
}
sum := calc(100, 200, sum)
```

> **1.byte类型**是**uint8的别名**，表示一个字节，
> **2.rune类型**是Go语言中的一个基本类型，其实就是一个**int32的别名**，主要用于表示一个字符类型大于一个字节小于等于四个字节的情况，特别是**中文字符**，中文格式是utf-8.

>九九乘法表
```go
//思想  j在前 i在后
// 第一行， j*i 1x1
// 第二行， j*i 1x1
// 第三行， j*i 1x1 ……
for i := 1;i < 10; i++ {
  for j := 1;j <=i; j++ {
    fmt.Printf("%v * %v = %v", j, i, j*i)
  }
  fmt.Printf("\n")
}
```
> 冒泡排序
```go
//思想：
// 第一次， a[1] 和 a[0] 比
// 第二次， a[2] 和 a[1] 比，然后a[1] 和 a[0]比
// 第三次， a[3] 和 a[2] 比，然后a[2] 和 a[1]比，……
func insert_sort(a [8]int) [8]int {
	for i := 1; i < len(a); i++ {
		for j := i; j > 0; j-- {
			if a[j] < a[j-1] {
				a[j], a[j-1] = a[j-1], a[j]
			} else {
				break
			}
		}
	}
	return a
}
```



> defer 函数中的defer表示定义一条语句，这条语句通常是函数调用，主要用来释放资源，它通常是在函数返回值返回之前调用，相当于放在甘薯体内的最后一行执行，如果是多个defer呢？谁在最下面先执行谁，即先打印v3后v2

```go
func calc() {
	defer fmt.Printf("hello")
  defer fmt.Printf("hello v2")
  defer fmt.Printf("hello v3")
  fmt.Printf("aaaa")
  fmt.Printf("bbbb")
}

//另一种情况，下面打印的是什么？正确的应该是 1000,1，因为虽然defer是最后执行，但defer定义的时候已经确定了i的值，不会改变了，下面的操作对i不影响
func calc() {
  var i int = 0
	defer fmt.Printf(i)
  i = 1000
  fmt.Printf(i)
}

// 还有一种情况,下面打印的是什么？正确的应该是 1000,1000，因为虽然defer后面是个匿名函数，这个函数里面的i不是传进去的，而i计算的时候值已经改变，所以是1000，注意匿名函数最后的括号表示立即执行，跟js的匿名函数差不多
func calc() {
	var i int = 0
  defer fun(){
    fmt.Printf(i)
  }()
  i = 1000
  fmt.Printf(i)
}
```

> close:主要用于关闭channel
>
> len:用于计算长度，比如字符串、数组、切片、map、channel
>
> new:用于分配内存，主要用于分配值类型，比如int、struct，返回指针
>
> make:用于分配内存，主要用于分配引用类型，比如切片、map、channel
>
> append:用于追加元素到数组或切片
>
> panic和recover:用于处理异常

> 特别要注意go中的除数运算与其他语言不同，例如下面的例子，其他语言会得出2.5，而go得出的是2，因为go是静态语言，a定义的时候是整形，那么结果也是一个整形，除非把a从整形转换为浮点型

```go
func main () {
	var a int = 52
	b := a/10
	fmt.Printf("b=%d", b)
} 
```

### 函数

```go
func Adder() func(int)int {
	var x int
	return func(d int)int {
		x += d
		return x
	}
}

// 这里f接收的是一个闭包
f := Adder()
ret := f(1)
fmt.Printf("f(1):ret=%d\n", ret)
ret = f(20)
fmt.Printf("f(20):ret=%d\n", ret)
ret = f(100)
fmt.Printf("f(100):ret=%d\n", ret)
```





























