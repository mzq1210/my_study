Gopath 项目路径


> &：符号的意思是对变量取地址。
> *： 是指针运算符 , 可以表示一个变量是指针类型 , 也可以表示一个指针变量所指向的存储单元 ，也就是这个地址所存储的值 。
> _：1.在导入的包前时，表示不需要把所有的包都导进来，只需要导入使用该包下的文件里所有的init()函数。常见	  于mysql、redis等包
> 2.在代码中表示忽略这个变量，也可以理解为占位符。
>
> ()：使用场景：除了常规的运算、函数及方法外，也可使用于类型转换、类型断言、复杂类型的边界
>
> ```go
> //类型转换
> a:=int32(100)
> 
> //类型断言
> v, ok := x.(string)
> 
> //复杂类型的边界
> type User struct{}
> 
> func (u *User) Show() {
> 	fmt.Println("hello. buddy")
> }
> 
> func main() {
> 	(&User{}).Show()
> }
> ```
>
> {} :除了函数、结构体及逻辑判断外，常用于集合
>
> ```go
> parts := []int{1, 2, 3}
> m := map[string]string{"a": "b", "c": "d"}
> ```
>
> []：常用于map、数组长度、切片定义、泛型类型
>
> ```go
> //map
> m := map[string]string{"a": "b", "c": "d"}
> //数组长度
> arr1 := [3]int{1, 2, 3}
> arr2 := [...]int{1, 2, 3, 4, 5}
> //切片定义
> nums := []int{1, 2, 3}
> ```
>
> 泛型类型：
> 1.函数定义， 定义传参泛型类型 : add[T Addable](a,b T)
> 2.函数调用， 指定传参特定类型: add[int]("a","b")
>
> ```go
> package main
> import "fmt"
> 
> type Addable interface {
> 	type int,string
> }
> 
> func add[T Addable](a,b T) {  
> 	fmt.Println(a+b)
> }
> 
> func main() {
> 	add(1,2)
> 	add("a","b")
> 	// add[int]("a","b") // 错误， 强制约束了传入为 int 类型
> }
> ```
>
```go
// 查看go的各种配置
go env

// go程序都需要编译，如果项目文件夹只有一层且就在src文件下，直接编译即可(注意编译指定到目录，不能指定到文件)
go build hello
// 如果项目是多层目录，则需要补全路径，注意src省略(注意编译指定到目录，不能指定到文件)
go build github.com/hello
// 默认情况下编译的二进制文件会放在项目根目录下，如果需要指定编译位置，hellotest是可执行文件的名字，可自定义
go build -o bin/hellotest github.com/hello

// 无需编译，直接运行（只适用于单文件，多文件的话需要把所有引用的文件都加上，很麻烦），注意这里需要加src
go run src/github.com/hello

// 直接安装二进制文件到bin目录，与go build -o bin/*作用一样
go install github.com/hello

// 编译之后会根据当前系统生成可执行文件，直接运行即可
./hello

// 单元测试
go test

// 格式化源代码，后面路径规则与build类似
go fmt github.com/hello

// 占位符：%d代表数字、%s代表字符串、%f代表浮点数、%v万能符,函数不能用万能符%v，而是用%T，%p代表内存地址
fmt.Printf("a=%d b=%s", a, b)

// 批量定义常量如果没有设置常量的类型和值，则自动继承上一个常量的类型和值
const(
	a=100
  b
)

// iota表示每隔一行自增，初始值为0，每次+1，则b=1，注意：iota是有作用域的，两个函数中的iota都是从0开始
const(
	a=iota
  b
  c
)

// iota每隔一行自增什么意思，如下：a=0，f隔行自增之后为5
const(
	a=iota
  b
  c
  d=8
  e
  f=iota
)

// 快捷定义变量
// 正常情况下定义一个变量是：
var a int
a=100
// 或
var a int = 100

// := 推导则可以快速定义变量,它可以根据值自动选择类型，相当于上面的两行，注意 := 只有在第一次定义变量的时候有效
a:=100
// 也可以定义多个
a,b := 100, 'test'

// package包，变量或者函数首字母大写可以通过外部访问，小写则为私有变量或方法，比如
fmt.Printf("a=%d b=%s", a, b)

// 英文字符串计算长度可直接用len()，因为其底层占1个byte字节，而中文字符串每个汉字占3个字节无法直接用len()计算会出现误差，因为len()计算的是字节数所以需要把中文字符转化为rune类型，rune类型进行切片后再使用len()计算长度。rune类型下面有介绍
// 注意:单引号代表字符，双引号代表字符串，中文不能使用单引号
str := "中"
fmt.Printf("a=%d\n", len(str))  // 3
var runeSlice []rune
runeSlice = []rune(str)
fmt.Printf("a=%d", len(runeSlice)) // 1

// 时间格式化，这里一定要写2006-01-02 15:04:05，不然格式化的时间不准
now := time.Now()
timeStr := now.Format("2006-01-02 15:04:05") 
fmt.Printf("a=%v", timeStr)

// if可以在结构体上定义变量，但这个变量的生命周期和作用域只在if结构体中，if结构体结束变量销毁
if num := 10; num % 2 == 0 {
  fmt.Printf("num=%v", num)
}else{
  fmt.Printf("num=%v", num)
}
// 这里就会报错
fmt.Printf("num=%v", num)

// for循环可以简写
i :=1
for i <=10 {
  i=i+2
}
// 也可以多个变量循环
for no, i := 10,1;i<=10 && no<=19; i,no = i+1, no+1 {
    fmt.Printf("i=%v no=%v", i, no)
}

// swich 多个case如果是同样的逻辑可以放到一起，且case也可以使用表达式
// fallthrough 放在case结构体中的最后一行，独占一行，意思是接着执行下面的case

// 函数，多个参数(如果连着两个参数的类型一样，可以只写一个类型)，多个返回值
func calc(a, b int)(sum int, sub int){
  sum = a + b
  sub = a - b
  return
}
// _代表省略，如果只对两数之和感兴趣，差就不需要接收变量了
sum, _ := calc(100, 200)

// 一次传零个或多个参数，这个时候b是一个数组
func calc(b ...int) int {
  sum := 0
  for i := 0,1;i < len(b); i++ {
    sum = sum + b[i]
	}
  return sum
}
sum := calc(100, 200, 300, 400)

// 函数可以赋值给一个变量，注意赋值的时候这个变量接收的是这个函数体，函数是没有运行的，如果要调用这个变量，可直接使用变量加上括号，括号里面传参，同样，匿名函数也可以赋值给一个变量
// 函数也可以作为一个参数传进去
func sum(a,b int) int {
  return a+b
}

func calc(a, b, op func(int int) int ) int {
  return op(a,b)
}
sum := calc(100, 200, sum)
```

> **1.byte类型**是**uint8的别名**，表示一个字节，
> **2.rune类型**是Go语言中的一个基本类型，其实就是一个**int32的别名**，主要用于表示一个字符类型大于一个字节小于等于四个字节的情况，特别是**中文字符**，中文格式是utf-8.

>九九乘法表
```go
//思想 为什么把i放在后面，因为后面的数是固定的，符合外层for的规律
// 第一行， j*i 1x1
// 第二行， j*i 1x1
// 第三行， j*i 1x1 ……
for i := 1;i < 10; i++ {
  for j := 1;j <=i; j++ {
    fmt.Printf("%v * %v = %v", j, i, j*i)
  }
  fmt.Printf("\n")
}
```
> 插入排序
```go
//思想：就像摸牌，先选出一张牌无论它大小，然后每次再掀一张与手中的所有牌进行对比插入。所以0作为首牌，i从1开始，i的牌给j，j与j-1比较，因为要和手中的所有牌对比，所以是j--，j为什么大于0？因为0号就是最小的牌，不能继续比下去了
// 第一次， a[1]和a[0]比较,小的插在前面
// 第二次， a[1]和a[2~n]之后所有的数比较,选出小的
// 第三次， 同上……
func insert_sort(a [8]int) [8]int {
	for i := 1; i < len(a); i++ {
		for j := i; j > 0; j-- {
			if a[j] < a[j-1] {
				a[j], a[j-1] = a[j-1], a[j]
      }else{
        break
      }
		}
	}
	return a
}
```

>选择排序

```go
//思想：每次都选出最小的放在前面，是i和j比较
// 第一次， a[0]和a[1~n]之后所有的数比较,选出最小的
// 第二次， a[1]和a[2~n]之后所有的数比较,选出小的
// 第三次， 同上……
func insert_sort(a [8]int) [8]int {
	for i := 0; i < len(a); i++ {
		for j := i+1; j < len(a); j++ {
			if a[j] < a[i] {
				a[j], a[i] = a[i], a[j]
			}
		}
	}
	return a
}
```
> 冒炮排序
```go
//思想：从小到大排序，是j和j+1比较，i为什么是1，是为了j的判断条件少比一次，因为如果不减1,j+1会溢出。注意和插入排序的区别，插入排序的每一轮都是首位与除了它之外的所有下标比较，而冒泡每一轮都是相邻的下标前后比较
// 第一次， 从头开始比，最大的在最后
// 第二次， 从头开始比，大的向后移
// 第三次， 同上……
func insert_sort(a [8]int) [8]int {
	for i := 1; i < len(a); i++ {
		for j := 0; j < len(a)-i; j++ {
			if a[j] > a[j+1] {
				a[j], a[j+1] = a[j+1], a[j]
			}
		}
	}
	return a
}
```

### defer


> defer表示定义一条语句，这条语句通常是函数调用，主要用来释放资源，它通常是在函数返回值返回之前调用，相当于放在函数体内的最后一行执行，如果有多个defer谁在下面谁先执行

```go
func calc() {
	defer fmt.Printf("hello")
	defer fmt.Printf("hello v2")
	defer fmt.Printf("hello v3")
	fmt.Printf("aaaa")
	fmt.Printf("bbbb")
}

//另一种情况，下面打印的是什么？正确的应该是 1000,1，因为虽然defer是最后执行，但defer定义的时候已经确定了i的值，不会改变了，下面的操作对i不影响
func calc() {
  var i int = 0
	defer fmt.Printf(i)
  i = 1000
  fmt.Printf(i)
}

// 还有一种情况,下面打印的是什么？正确的应该是 1000,1000，因为虽然defer后面是个匿名函数，这个函数里面的i不是传进去的，而i计算的时候值已经改变，所以是1000，注意匿名函数最后的括号表示立即执行，跟js的匿名函数差不多
func calc() {
	var i int = 0
  defer fun(){
    fmt.Printf(i)
  }()
  i = 1000
  fmt.Printf(i)
}
```

> close:主要用于关闭channel
>
> len:用于计算长度，比如字符串、数组、切片、map、channel
>
> new:用于分配内存，主要用于分配值类型，比如int、struct，返回指针
>
> make:用于分配内存，主要用于分配引用类型，比如切片、map、channel
>
> append:用于追加元素到数组或切片
>
> panic和recover:用于处理异常

> 特别要注意go中的除数运算与其他语言不同，例如下面的例子，其他语言会得出2.5，而go得出的是2，因为go是静态语言，a定义的时候是整形，那么结果也是一个整形，除非把a从整形转换为浮点型

```go
func main () {
	var a int = 52
	b := a/10
	fmt.Printf("b=%d", b)
} 
```

### 函数

```go
func Adder() func(int)int {
	var x int
	return func(d int)int {
		x += d
		return x
	}
}

// 这里f的类型取决于Adder是否加了括号，因为加上括号就相当于执行了启动，启动就有返回值，如果没有加括号f的类型就是整个结构体，如果加了括号f就是函数运行之后的返回值，即匿名函数
f := Adder()
ret := f(1)
fmt.Printf("f(1):ret=%d\n", ret)
ret = f(20)
fmt.Printf("f(20):ret=%d\n", ret)
ret = f(300)
fmt.Printf("f(100):ret=%d\n", ret)
```

### 闭包
> 概念：**指有权访问另一个函数作用域中变量的函数**。简单理解就是 ，**一个作用域可以访问另外一个函数内部的局部变量**。
> 作用：**延伸变量的作用范围。**

使用js举个例子
```js
/*需求分析
打车起步价13(3公里内),  之后每多一公里增加 5块钱.  用户输入公里数就可以计算打车价格
如果有拥堵情况,总价格多收取10块钱拥堵费*/
 
var car = (function() {
     var start = 13; // 起步价  局部变量
     var total = 0; // 总价  局部变量
     return {
       // 正常的总价
       price: function(n) {
         if (n <= 3) {
           total = start;
         } else {
           total = start + (n - 3) * 5
         }
         return total;
       },
       // 拥堵之后的费用
       yd: function(flag) {
         return flag ? total + 10 : total;
       }
	}
 })();
console.log(car.price(5)); // 23
console.log(car.yd(true)); // 33
```

### 数组

> 1.缺点：长度一旦定义就无法改变，即使[...]也一样，长度在它赋值的时候就已经确定了，即可以修改但无法再增加新元素
>
> 2.当数组作为参数传入到函数中时，也是把那个数据拷贝了一份，修改参数不会改变原数组的值，如果原数组数据过大，则很影响效率

### 切片（引用类型）

> 1.是基于数组类型做的一层封装，可以自动扩容，意思是切片的底层也是数组。注意定义的时候与数组的区别，[]中有数字就是数组，没有数字就是切换。
>
> 2.切片是左开右闭原则，比如[1:3]是从下标1~2，不包括3
>
> 3.修改切片中的值会对原数组也进行修改，说明切片是对数组的引用，而不是复制
>
> 4.定义一个空切片，其长度和容量都是0，append追加扩容从1开始
>
> 5.切片定义之后不能直接使用(这里指不能直接根据索引下标赋值，append是可以的)，需要make初始化，也可以把两个语句写到一起，定义的时候直接使用make初始化

```go
//生成一个指定容量的空切片
var a []int = make([]int, 0, 10)

// make创建切片，理解长度（前5）和容量（后10），长度代表目前占用的数组空间，容量代表数组总的空间数
var a []int
a = make([]int, 5, 10)
// 但是如果直接设置a[5]是会报错的，因为数组不会自动扩容，需要用append进行扩容
a[5] = 100           //错误
a = append(a, 100)   //正确

//如果是这种情况呢？长度和容量分别是多少？
a := [...]int{0,1,2,3,4,5,6,7}
b = a[1:3]
// 答案是 长度2 容量7，长度好理解为什么容量是7，因为切片是对数组的引用，所以切片分割的时候会把切下来的部分作为长度，而会把从起点开始切割到原数组的最后作为切片的默认容量
// 切片之后再切片呢？结果是1~7，因为第一次切片之后，原切片的长度是1~2，容量是1~7，而第二次切片是在第一次切片的容量基础上切的，所以是1~7.注意：切的是第一次切片的容量而不是长度
b = b[:cap(b)]
```

> 扩容
>
> 1.扩容到最大的时候继续append会怎么样呢？会继续扩容，规则是目前的容量基础上翻倍扩容，也就是会变为20，接下来是40,80,160
>

```go
// 定时器的使用
time.Tick(1*time.Second)
// eg:每两秒执行一次do_some_thing()函数
for range time.Tick(2 * time.Second ) {
  do_some_thing()
}

// 生成一个随机数种子，为什么要加随机数种子？因为不加随机数种子，对于一次执行来说，我们看到的是随机的，但是对于多次执行来说，便失去了随机性，运行的结果还是第一次的结果。
func main() {
    rand.Seed(time.Now().Unix())
    for i := 0; i <= 10; i++ {
        fmt.Println("My first lucky number is", rand.Intn(10))
        fmt.Println("My senond lucky number is", rand.Intn(10))
    }
}

// 生成一个0~99的随机数
rand.Intn(100)
// 生成一个1~100的随机数
rand.Intn(100 - 1+1) + 100
```

### 指针

> 指针类型和引用类型是一样的东西，指针类型也需要定义，注意：切片也是引用类型，作为参数传递就不需要加*了

```go
b := 32
// 类型前加上*号就是定义指针类型，也就是引用类型，他就是用来存储内存地址的
var a *int32 = &b
// 而变量前面加*号，意思就是把引用地址的值取出来，比如把b的值改为64
*a = 64
// 数组指针引用要加括号
(*a)[0] = 100
```

### map（引用类型）

> 1.map属于引用类型，所以作为函数参数传递时也不需要加*
>
> 2.格式类似于其他语言中的key->value关联数组
>
> 3.map定义之后必须使用make初始化才能使用

[map内存泄漏](https://mp.weixin.qq.com/s/s5-Pl5u6yoZCPWwoeINs9g)

```go
//初始化，int是key的类型，string是value的类型
a := make(map[int]string)
a[1] = 'test'

// 看这种格式，a[2]可以返回两个值，result是用来接收返回值，ok是用来判断值是否存在，这是特殊的语法格式
var result int
var ok bool
result, ok = a[2]

// 删除某个元素，批量删除只能for循环
delete(a, 'test')

// 1.注意看这两个定义方式,这个是定义了一个切片，切片中元素的类型是map，即map[string]int
var a []map[string]int
a = make([]map[string]int, 5, 16) //初始化切片
a[0] = make(map[string]int, 8)    //初始化切片之后map也无法使用，还要初始化map

// 2.这个是定义了一个map，key是[string]，value是[]int，也就是切片
var a map[string][]int
a = make(map[string][]int, 5, 16) //初始化map
a["stu01"] = make([]int, 0, 16)		//初始化map之后切片还是不能使用的，还要初始化切片
```

### interface类型（可以存储任意类型）

```go
// 存储学生信息，因为一条学生信息包含各种类型比如年龄、姓名，所以使用interface
// 内部存储格式类似于：stuMap[1][['id':1,'name':'myname','age':19],['id':1,'name':'myname','age':19]]
var stuMap map[int]map[string]interface{}
stuMap = make(map[int]map[string]interface{}, 16)
value, ok := stuMap[1]
if !ok{
  value = make(map[string]interface{}, 16)
}
value["id"] = 1
value["name"] = "aaa"
value["age"] = 19
```

### init执行顺序：引用的包中的init先执行

### struct结构体

```go
// 注意这里的p是实例的一个副本，修改p的属性不会改变传入的那个实例的属性
func (p People) Print() {
  fmt.Printf("$d", p.name)
}

// 所以一般用这种形式，把实例的指针传进来
func (p *People) Print() {
  fmt.Printf("$d", p.name)
}
//结构体实例化的时候，虽然这个方法的p是一个指针类型，但实例的前面不需要加*,因为go底层的语法糖会自动转换为实例的地址
var p1 People = People{
  Name: "test",
  Age: 18
}
p1.Print()
//这种写法是什么？？？？，据说go底层是这么写的，见listen9，listen12，构造函数也在listen12
(&p1).Print()
//强制把json转换为切片类型，类似于原生的 strings()，见listen3
[]byte(json)

//格式化输入输出
fmt.Scanf   //遇到换行不结束，换行会作为第二个参数传进去，以此类推
fmt.Scan    //自动处理换行
fmt.ScanLn  //遇到换行就结束
fmt.Sscanf  //从字符串变量中读取以空格作为分隔符的参数
```

### 断言

> 简单的来理解就是判断的意思，在Go中类型断言可以理解成对类型的判断。

```go
//x 表示一个接口的类型，T 表示一个具体的类型（也可为接口类型）。该断言表达式会返回 x 的值（也就是 value）和一个布尔值，可根据该布尔值判断 x 是否为 T 类型：
value, ok := x.(T)
```



### 使用过的包

```go
time
// 用过的包
// flag
flag.IntVar() 接收命令行输入的参数
flag.StringVar() 接收命令行输入的参数
//strings
ips := "10.108.34.30;10.108.34.31"
ipArray:= strings.Split(ips, ";")
result := strings.Contains(ips, "10.108.34.31")

json.Marshal() json.Unmarshal() 
```





并发课程里有 chan(通道) 和 锁

[chan的解释](https://www.cnblogs.com/xinliangcoder/p/11286801.html)：chan 可以理解为队列，先进先出。

grom就相当于yii框架中的ORM数据库查询















