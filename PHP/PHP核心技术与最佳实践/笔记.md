**类是一个动作和属性的模板，对象是数据的集合**

serialize()把对象序列化后可以发现，数据存储的只是对象的**属性**，对象本身并不包含**方法**，但对象有一个指针指向了具体的类，类中包含方法。

一个字段使用**二进制**识别8个status状态

**__call**链式调用

**::**有两种应用不要混淆，一种是调用父类的方法，一种是调用类常量和静态方法

区分**继承与组合**，父子是继承关系（强调像），父亲+儿子是一个家庭组合（强调需要），在实际开发中取舍并不是那么直接明了，所以采用哪种方式根据需求来。但组合在解耦和语义上来说要**优于**继承，比如定义鸟为父类，具有羽毛属性和飞翔方法，子类有天鹅、鸭子、鸵鸟，显然鸭子、鸵鸟不需要飞翔但他们却有飞翔这个方法，破坏了封装性。这并不代表组合就没有缺点，组合得缺点就是需要一一创建局部对象，增加了代码量，而继承可以复用。

继承中子类要着重扩展父类的方法而不是覆盖父类的方法。底层多用组合方便扩展，顶层多用继承可以提高灵活性。

有没有既可以实现组合的灵活又可以继承代码的简洁呢？多重继承是个好方法，但多重继承过于灵活且会带来菱形问题，所以加入了**Traits**，**Traits**和**接口**都是对“多重继承”的一种变相实现。

**多态**确切的含义是：同一个类的对象收到相同消息时会得到不同的结果，而这个消息时不可预测的。多态，顾名思义就是多种状态，也就是多种结果。它真正的意义在于：**实际开发过程中，只要关心一个接口或基类的编程，而不必关心一个对象所属于的具体类**。php为什么说没有多态，因为php作为弱类型语言本身就是多态的，是否是多态的关键在于看对象是否属于同一类型，如果把他们看做同一类型，调用相同的函数返回了不同的结果，那他就是多态。

接口：**对于实现我的所有类，看起来都应该像我现在这个样子**，接口是抽象类的变体，是一种契约。因此在程序中接口的方法必须你=被全部实现。但因为php属于弱类型语言，所以并不推荐大规模使用而应该仅在部分内核代码中使用，因为php中的接口已经失去了很多接口应该具有的语义，更多的应该使用抽象类。

**反射：**指在php运行状态中扩展分析php程序，导出或提取关于类、方法、属性、参数、注释等的详细信息，这种动态获取信息以及动态调用对象方法的功能称为反射API。

```php
//反射api
$obj = new \ReflectionObject($student);
$props = $obj->getProperties();
foreach ($props as $prop) {
    print $prop->getName() . "\n";
}
$methods = $obj->getMethods();
foreach ($methods as $m) {
    print $m->getName() . "\n";
}

//不使用反射api
$obj = get_object_vars($student);
$props = get_class_vars(get_class($student));
$methods = get_class_methods(get_class($student));
//如果这个对象是从其他页面传过来的
get_class($student);
```

反射可以用来扫描文件里的类生成描述文档，也可以用它做hook实现插件功能，或者是做动态代理（比如获取正在运行的mysql类中的方法，在特定的方法前后进行拦截，动态的改变mysql类的方法和属性）。

区分**异常**和**错误**，php遇到非正常代码通常会触发错误，而错误是无法用**try...catch**拦截捕获的，而是直接报错，比如文件打不开，数据库连接不上去、计算除法时除数为0。捕获异常时要把自定义需要分门处理的放在上面的catch，而把exception超类放在最下面的catch。

**异常**偏向于保护业务数据一致性，并且强调对异常业务的处理。如果代码中只是象征性的**try...catch**然后打印一个报错，这样的异常不如不用，因为其没有体现出异常的思想。所以合理的结构如下，比如上传一个文件并在数据库中加一条记录：

```php
try{
    if(文件上传不成功) throw(上传异常);
    if(插入数据不成功) throw(数据库操作异常);
}cache(上传异常){
    必要的补救措施，如删除文件、删除数据库插入的记录，这个处理很细致，一定要保持数据一致性
}cache(上传异常){
    必要的补救措施，如删除文件、删除数据库插入的记录，这个处理很细致，一定要保持数据一致性
}cache(其他异常){
    记录log
}
```

只有一个catch属于立即捕获，多个catch属于分散抛异常集中捕获，对于重要的业务来说异常越早处理越好，要保证业务处理的一致性，而对于mvc来说更多强调业务流程的走向，一般采用分散捕获，自定义异常一般继承RuntimeException。

#### 设计模式表达的是类与类之间的关系，它只是一种成熟的可供借鉴的思考模式，而不是公式

《设计模式》五星  

《敏捷软件开发--原则、方法与实践》四星半 推荐

### 设计模式的五种原则

**单一职责**的两个含义：一个是避免相同的职责分散到不同的类中，二是避免一个类承担太多职责。典型的就是修电脑和修电视机，电视机各个部件之间的耦合度太高不易修理，电脑则换个配件即可。

**接口隔离：**客户端不应该被强迫实现一些他们不会使用的接口，即一个类对另外一个类的依赖性应当是建立在最小的接口上的。例如经理和普通员工都继承自雇员的接口，员工每天需要写日志而经理不需要，因此不能用日志来卡经理，也就是经理不应该依赖于提交日志这个方法。可以看出，它和单一职责在概念上是有交叉的。**事实上，很多设计模式在概念上都有交叉，甚至很难判断一段代码属于哪一种设计模式。**

**开放封闭原则**

**替换原则**

**依赖倒置原则** 难理解难实现

> 注意接口是**相对**稳定的，也就是说无论使用多么先进的设计模式也无法做到不需要修改代码即可达到以不变应万变的地步。



```mysql
#查看读写比例COM_XXX，选择合适的存储引擎
show global status;
#查看慢日志是否开启
show variables like '%slow%'
#查看慢查询的条数
show global status like '%slow%'
#查看最大连接数
show variables like 'max_connections%'
#从表中删除了大量数据后，可进行碎片整理
OPTIMIZE TABLE nc_history_log
```

PDO是对多种数据库的统一封装，主要功能是参数绑定和预编译，但这样势必会造成一定的资源损耗，因为PDO向mysql查询时是先把模板发送过去，再把参数发送过去，多产生了一次请求。

mysql索引类型至少要达到range级，最好达到ref级，all级是全表扫描，每个表的索引应该在5个以下，因为维护索引需要成本。也不要在结果单一的列上建索引，比如性别字段只有0和1，建了索引效果也不大。

通常观点是myIsam注重性能，innoDB注重事务，但那是在很久之前，而现在innoDB的行级锁对比myIsam的表级锁在并发状态下性能也提升了不少，唯一的代价是innoDB需要更大的内存，因为innoDB的索引包含了数据。

关于存储引擎的选择，运行命令：show global status 查看COM_XXX，对比select和update（即读和写）的比例。理想状态下100:1选择myIsam，一般都是30:1，两者都可，10:1的时候就要选择innoDB了。

优化存储引擎配置：

1.适当增加最大连接数

2.对于myIsam要关注 key_buffer_size和table_cache，对于innoDB则需要关注 innodb_buffer_pool_size

**报表统计可以创建冗余字段，对数据进行定期转储**











