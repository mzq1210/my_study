```bash
#查看mysql支持哪些引擎
SHOW ENGINES;
#如果无法回滚可能是你以为支持事务其实不支持，可以改一下表引擎试试
alter table user engine=innoDB;

#查看表的存储引擎，myisam是不支持事物的
show create table user;
#查看事务是否开启了自动提交
show variables like 'autocommit';
#关闭自动提交
set autocommit=0;

#查看mysql隔离级别
show variables like 'tx_isolation';
#设置read uncommitted级别：
set tx_isolation = 'read-uncommitted';
#设置read committed级别：
set tx_isolation = 'read-committed';
#设置repeatable read级别：
set tx_isolation = 'repeatable-read';
#设置serializable级别：
set tx_isolation = 'serializable';
```

首先用通俗的语言介绍一下事务的特性（**ACID**）：
​       **原子性**：指一个事务中的操作，要么全部成功，要么全部失败，如果失败，就回滚到事务开始前的状态。
​       **一致性**：指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账举例，A账户和B账户之间相互转账，无论如何操作，A、B账户的总金额都必须是不变的。
​       **隔离性**：指当多个用户并发访问数据库时，如果操作同一张表，数据库则为每一个用户都开启一个事务，且事务之间互不干扰，也就是说事务之间的并发是隔离的。举个栗子，现有两个并发的事务T1和T2，T1要么在T2开始前执行，要么在T2结束后执行，如果T1先执行，那T2就在T1结束后在执行。
​       **持久性**：指事务一旦被提交，数据库中数据的改变就是永久性的，即使断电或者宕机的情况下，也不会丢失提交的事务操作。


如果不考虑隔离性，会发生什么事呢？

**脏读**：脏读是指一个事务在处理数据的过程中，读取到另一个未提交事务的数据。
**不可重复读**：不可重复读是指对于数据库中的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了。
不可重复读和脏读的区别是，脏读读取到的是一个未提交的数据，而不可重复读读取到的是另一个事务提交的数据。
而不可重复读在一些情况也并不影响数据的正确性，比如需要多次查询的数据也是要以最后一次查询到的数据为主。
**幻读**：幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。
幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。
不可重复读和幻读是初学者不易分清的概念，总的来说，解决不可重复读的方法是 锁行，解决幻读的方式是 锁表。



1.读未提交（Read uncommitted）：

​       该隔离级别下，select语句不加锁。此时可能读取到不一致的数据，即“读脏 ”。这是并发最高，一致性最差的隔离级别。

2.读已提交（Read committed）：

​       可避免 脏读 的发生。在互联网大数据量，高并发量的场景下，几乎 不会使用 上述两种隔离级别。阿里使用

3.可重复读（Repeatable read）：

​       MySql默认隔离级别。可避免 脏读 、不可重复读 的发生。

4.串行化（Serializable ）：

​       可避免 脏读、不可重复读、幻读 的发生。以上四种隔离级别最高的是 Serializable 级别，最低的是 Read uncommitted 级别，级别越高执行效率就越低。像 Serializable 这样的级别，就是以锁表的方式，使得其他的事务只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。



读锁/共享锁：（大家一起只能看不能动）都能读但都不能写，当前事务插入或更新直接报错，其他事务一直等待

```mysql
select * from user where a = 2 lock in share mode
```

写锁/排他锁：（自己能动，其他人不能动，看也不行）当前事务任意操作，其他事务禁止一切操作

```mysql
select * from user where a = 2 for update
```



1.如果是最低级别**读未提交**，因为事务A会读取到事务B已修改但尚未提交的数据所以会出现**脏读**问题，为了解决**脏读**提高了一个隔离级别**读已提交**，但读已提交在事务A中如果在不同时刻读取数据会出现数据不一致的现象：**不可重复读**问题（比如在A事务中前一毫秒读取的是数据未改变之前的，后一秒读取的是事务B已提交的数据），当然这种问题在某些场景下是可以容忍的，因为事务A最后读到的是最新的数据，阿里巴巴这种查询比较多的适合用这种隔离级别。不过如果放到转账或者ERP对某个时间节点的数据一致性要求比较高的场景显然不合适，那就需要再提高了一个隔离级别**可重复读**，A事务中数据始终可以保持与第一次查询的一致（重复读的隔离级别下使用了MVCC机制），相当于除了第一次之后的所有查询读取的数据都是第一次读取时间点的快照（历史版本），select操作不会更新版本号，insert、update和delete会更新版本号。这种隔离级别虽说数据可以始终保持一致，但线程阻塞却增大了，对应降低了并发数。同时**可重复读**会出现**幻读**问题（事务A读取到了事务B提交的新增数据，不符合隔离性），意思是事务A未提交期间，事务B修改提交之后又增加了一条数据，而事务A也能读取到这条新增的数据，这样也不对。所以可以再提高了一个隔离级别**串行化**，但在**串行模式**下innodb的查询会被加上行锁，比如事务A读取id=1的数据期间事务B更新id=1的记录会被阻塞等待，而更新id=2的记录可以成功。如果事务A执行的是一个范围查询，那么该**范围内的所有行包括每行记录所在的间隙区间范围**(就算该行数据 
还未被插入也会加锁，这种是间隙锁)**都会被加行锁**。此时如果客户端B在该范围内插入数据都会被阻塞，所以就 
避免了幻读。这种隔离级别并发性极低，开发中很少会用到。而Mysql默认级别是repeatable-read，有办法解决幻读问题吗？间隙锁在某些情况下可以解决幻读问题。

锁主要是加在索引上，如果对非索引字段更新，行锁可能会变表锁**(RR级别会升级为表锁，RC级别不会升级为表锁)** 



**锁优化建议** 
1.尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁 
2.合理设计索引，尽量缩小锁的范围 
3.尽可能减少检索条件范围，避免间隙锁 
4.尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行 
5.尽可能低级别事务隔离 

**MVCC多版本并发控制隔离机制**?????