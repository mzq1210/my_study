[TOC]



### 基本语句

```bash
#查看mysql支持哪些引擎
SHOW ENGINES;
#如果无法回滚可能是你以为支持事务其实不支持，可以改一下表引擎试试
alter table user engine=innoDB;

#查看表的存储引擎，myisam是不支持事物的
show create table user;
#查看事务是否开启了自动提交
show variables like 'autocommit';
#关闭自动提交
set autocommit=0;

#查看mysql隔离级别
show variables like 'tx_isolation';
#设置read uncommitted级别：
set tx_isolation = 'read-uncommitted';
#设置read committed级别：
set tx_isolation = 'read-committed';
#设置repeatable read级别：
set tx_isolation = 'repeatable-read';
#设置serializable级别：
set tx_isolation = 'serializable';
```



### 事务特性（ACID）

- **原子性**：指一个事务中的操作，要么全部成功，要么全部失败，如果失败，就回滚到事务开始前的状态。
- **一致性**：指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账举例，A账户和B账户之间相互转账，无论如何操作，A、B账户的总金额都必须是不变的。
- **隔离性**：指当多个用户并发访问数据库时，如果操作同一张表，数据库则为每一个用户都开启一个事务，且事务之间互不干扰，也就是说事务之间的并发是隔离的。举个栗子，现有两个并发的事务T1和T2，T1要么在T2开始前执行，要么在T2结束后执行，如果T1先执行，那T2就在T1结束后在执行。
- **持久性**：指事务一旦被提交，数据库中数据的改变就是永久性的，即使断电或者宕机的情况下，也不会丢失提交的事务操作。

#### 如果不考虑隔离性，会出现什么问题？

> **脏读**：指一个事务在处理数据的过程中，读取到另一个未提交事务的数据。
> **不可重复读**：指对于数据库中的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了。
> 不可重复读和脏读的区别是，脏读读取到的是一个未提交的数据，而不可重复读读取到的是另一个事务已提交的数据。不可重复读在一些情况并不影响数据的准确性，因为多次查询的数据都是以最后一次查询到的数据为主。
> **幻读**：幻读是事务非独立执行时发生的一种现象（事务A读取到了事务B提交的新增数据）。例如事务T1对一个表中某个范围的某个字段做了1改为2的更新操作，这时事务T2又向这个表中插入了一行新增数据，而这条新增数据的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是幻读。
> 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），不同的是不可重复读查询的都是已存在的同一个数据，而幻读针对的是一批数据整体中新增的数据。
> 解决不可重复读的方法是**锁行**（单条），解决幻读的方式是**锁表**（整体）。



### 隔离级别

- 读未提交（Read uncommitted）：
​       该隔离级别下，select语句不加锁。此时可能读取到不一致的数据，即**读脏**。这是并发最高、一致性最差的隔离级别。

- 读已提交（Read committed）：
  ​       可避免**脏读**的发生，但会有**不可重复读**的问题。如果解决呢？这里可以引入**MVCC**多版本并发控制，**MVCC**可以做到读写不阻塞，且避免了脏读的问题。在互联网大数据量高并发场景下，几乎不会使用上述两种隔离级别，但类似于阿里查询比较多的业务会使用此级别。

- 可重复读（Repeatable read）：
  ​       可避免**脏读** 、**不可重复读**的发生，但同时会出现**幻读**问题（MySql默认隔离级别）。

- 串行化（Serializable ）：
  ​       可避免**脏读**、**不可重复读**、**幻读**的发生，但因阻塞执行效率会大大降低。串行化通常是以锁表的方式，使得其他的事务只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。


1.如果是最低级别**读未提交**，因为事务A会读取到事务B已修改但尚未提交的数据所以会出现**脏读**问题，为了解决**脏读**提高了一个隔离级别**读已提交**，但读已提交在事务A中如果在不同时刻读取数据会出现数据不一致的现象：**不可重复读**问题（比如在A事务中前一毫秒读取的是数据未改变之前的，后一秒读取的是事务B已提交的数据），当然这种问题在某些场景下是可以容忍的，因为事务A最后读到的是最新的数据，阿里巴巴这种查询比较多的适合用这种隔离级别。不过如果放到转账或者ERP对某个时间节点的数据一致性要求比较高的场景显然不合适，那就需要再提高了一个隔离级别**可重复读**，A事务中数据始终可以保持与第一次查询的一致（重复读的隔离级别下使用了MVCC机制），相当于除了第一次之后的所有查询读取的数据都是第一次读取时间点的快照（历史版本），select操作不会更新版本号，insert、update和delete会更新版本号。这种隔离级别虽说数据可以始终保持一致，但线程阻塞却增大了，对应降低了并发数。同时**可重复读**会出现**幻读**问题（事务A读取到了事务B提交的新增数据，不符合隔离性），意思是事务A未提交期间，事务B修改提交之后又增加了一条数据，而事务A也能读取到这条新增的数据，这样也不对。所以可以再提高了一个隔离级别**串行化**，但在**串行模式**下innodb的查询会被加上行锁，比如事务A读取id=1的数据期间事务B更新id=1的记录会被阻塞等待，而更新id=2的记录可以成功。如果事务A执行的是一个范围查询，那么该**范围内的所有行包括每行记录所在的间隙区间范围**(就算该行数据 
还未被插入也会加锁，这种是间隙锁)**都会被加行锁**。此时如果客户端B在该范围内插入数据都会被阻塞，所以就 
避免了幻读。这种隔离级别并发性极低，开发中很少会用到。而Mysql默认级别是repeatable-read，有办法解决幻读问题吗？间隙锁在某些情况下可以解决幻读问题。

锁主要是加在索引上，如果对非索引字段更新，行锁可能会变表锁**(RR级别会升级为表锁，RC级别不会升级为表锁)** 



### 锁机制

#### 乐观锁

乐观锁是开放策略：“先处理业务，再申请锁”， 实现方式就是加版本号，如果与其他事务有锁冲突，让用户决定如何去进行下一步，如重试或回滚。优点是并发控制没有实际加锁，没有额外开销，也不会出现死锁问题，适用于读多写少的并发场景。缺点是由于会出现不少的写冲突，致使数据写入要屡次等待重试，在这种状况下，其开销其实是比悲观锁更高的。并且乐观锁的业务逻辑比悲观锁要更为复杂，业务逻辑上要考虑到失败，等待重试的状况，并且也没法避免其余第三方系统对数据库的直接修改的状况。

#### 悲观锁

悲观锁是保守策略：“先取锁，成功了才访问数据”，优点是保证了数据获取和修改都是有序进行的，所以适合在写多读少的环境中使用。缺点就是因为需要加锁，可能面临锁冲突甚至死锁的问题。

##### 悲观锁之读锁、写锁、互斥锁、⾃旋锁

读锁/共享锁：（大家只能看不能动）都能读但都不能写，当前事务插入或更新直接报错，其他事务一直等待

```mysql
select * from user where a = 2 lock in share mode
```

写锁/排他锁：（自己能动，其他人不能动，看也不行）当前事务任意操作，其他事务禁止一切操作

```mysql
select * from user where a = 2 for update
```



#### 锁优化建议

1. 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
2. 合理设计索引，尽量缩小锁的范围
3. 尽可能减少检索条件范围，避免间隙锁
4. 尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行
5. 尽可能低级别事务隔离



### MVCC多版本并发控制隔离机制

**乐观锁**和**悲观锁**都是经过延迟或者终止相应的事务来解决事务之间的竞争条件保证事务的可串行化；虽然他们可以解决并发事务的可串行化的问题，可是其实都是在解决写冲突的问题，二者区别在于对写冲突的乐观程度不一样(悲观锁也能解决读写冲突问题，可是性能一般)。而在实际使用过程中，数据库读请求是写请求的n多倍，若是能解决读写并发的问题就能更大地提升数据库的读性能，而这就是MVCC所要做到的事情。

MVCC可以在提升并发量的同时做到读写不阻塞，且避免了脏读问题。MVCC读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的历史版本，不用加锁。当前读，读取的是数据记录的最新版本，读取的记录都会加上锁，保证其他事务不会再并发修改这条记录。

思想：在读取的时候生成一个**版本号**，等到其他事务 commit 了之后，才会读取最新已 commit 的**版本号** 。比如说：事务 A 读取了记录 (生成版本号)，事务 B 修改了记录 (此时加了写锁)，事务 A 再读取的时候，是依据最新的版本号来读取 (当事务 B 执行 commit 了之后，会生成一个新的版本号)，如果事务 B 还没有 commit，那事务 A 读取的还是之前版本号的数据。

**可重复复读**是如何依靠MVCC避免幻读的问题呢？

**可重复复读**隔离级别是「事务级别」的快照！每次读取的都是「当前事务的版本」，即使当前数据被其他事务修改了 (commit)，也只会读取当前事务版本的数据。这样就解决了幻读问题，而如果是当前读（指的是 select * from table for update），则需要配合间隙锁来解决幻读的问题。



#### MVCC原理

MVCC 的主要是通过 read view 和 undo log 来实现的
undo log 前面也提到了，它会记录修改数据之前的信息，事务中的原子性就是通过 undo log 来实现的。所以，有 undo log 可以帮我们找到「版本」的数据
而 read view 实际上就是在查询时，InnoDB 会生成一个 read view，read view 有几个重要的字段，分别是：trx_ids（尚未提交 commit 的事务版本号集合），up_limit_id（下一次要生成的事务 ID 值），low_limit_id（尚未提交版本号的事务 ID 最小值）以及 creator_trx_id（当前的事务版本号）
在每行数据有两列隐藏的字段，分别是 DB_TRX_ID（记录着当前 ID）以及 DB_ROLL_PTR（指向上一个版本数据在 undo log 里的位置指针）
很容易就发现，MVCC 其实就是靠「比对版本」来实现读写不阻塞，而版本的数据存在于 undo log 中。
而针对于不同的隔离级别（read commit 和 repeatable read），无非就是 read commit 隔离级别下，每次都获取一个新的 read view，repeatable read 隔离级别则每次事务只获取一个 read view



[锁问题](https://www.51cto.com/article/666378.html)