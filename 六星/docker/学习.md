一、

#### Centos 安装docker

```bash
#1、更新update到最新的版本  
yum  update
#2、卸载老版本docker
yum  remove docker  docker-common docker-selinux  docker-engine
#3、安装需要的软件包
yum install -y yum-utils  device-mapper-persistent-data lvm2
#4、设置yum源
yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
#5、查看docker版本
yum list docker-ce --showduplicates|sort -r  
#6、安装docker
yum  install  docker-ce-18.03.1.ce -y
#7、启动docker
systemctl start docker
#查看状态
systemctl status docker
#8、加入开机自启
systemctl enable docker
#9、配置国内镜像
vi /etc/docker/daemon.json 
{
"registry-mirrors": ["http://hub-mirror.c.163.com"]
}
#10.更换docker国内源需要重启
systemctl restart docker
```

#### docker常用指令

```bash
#1.启动
docker start 容器名
#2.删除
docker rm 容器名
#3.停止/删除所有容器
docker stop  $(docker ps -a -q)
docker rm  $(docker ps -a -q) 
#删除镜像，i代表image
docker rmi  $(docker ps -a -q) 

#4.根据Dockerfile构建镜像
docker build -t 名称 .
-t ，--tag list  #构建后的镜像名称
-f， --file string #指定Dockerfiile文件位置
示例：
1，docker build . 
2，docker build -t redis:v1 .
3，docker build -t redis:v2 -f /path/Dockerfile /path
一般常用第2种方式构建，我们在构建时都会切换到Dockerfile文件的目录下进行构建，所以不需要指定-f参
#查看构建镜像历史记录，方便查错
docker history 镜像ID
#查看构建容器日志，方便查错
docker logs 容器id
#Dockerfile调错：有一种情况是无法查看日志，一构建就退出，找不到原因，那就先把dockerfile文件中的CMD命令注释掉，docker run 构建的命令最后加上bash,直接进入容器运行应用启动命令

#5、使用此docker镜像 创建容器
docker run -itd --name  redis-master  --net mynetwork  -p 6380:6379  --ip 192.168.1.2  redis 
-d:     后台运行容器，并返回容器ID；  
-i:     以交互模式运行容器，通常与 -t 同时使用；
-p:     端口映射，格式为：主机(宿主)端口:容器端口
-t:     为容器重新分配一个伪输入终端，通常与 -i 同时使用；
-V:     为容器挂载目录，比如 /usr/docker/data:/data 前者为数宿主机目录后者为容器内目录
--ip:   为容器制定一个固定的ip 
--net:  指定网络模式

#6.查看容器信息
docker inspect 容器名

#7.进入容器
docker exec -it 容器 bash

#8.重启容器，两种方式
#exec代表在容器在执行一个命令
docker restart nginx
docker exec nginx nginx -s load

#导出容器
docker export 已存在的容器id/name > 文件名.tar
docker save 已存在的容器id/name > 文件名.tar
#导入容器
docker import 文件名.tar 容器自定义name
docker load < 文件名.tar
```

> 注意他们与save\load的区别，两对命令都能导入导出，save方式导出的文件比export方式导出的文件大，因为save方式保存了镜像的历史和层，使其可以回滚到之前的历史层。反观export方式，在导出过程中丢失所有的历史，导致其不可以层回滚，导出的文件会小一些。

#### 容器网络

```bash
#Docker安装后，默认会创建三种网络类型，查看所有：
docker network ls

#默认情况下启动Docker容器都是使用桥接方式bridge，每次Docker容器重启时，会按照顺序获取对应的IP地址，这个就导致重启下，Docker的IP地址就变了。所以我们需要创建自定义网络并指定网段：192.168.1.0/24，命名为mynetwork
docker network create --subnet=192.168.1.0/24 mynetwork
docker network ls

#查看自定义网络信息
docker network inspect mynetwork
#查看某个容器的网络信息
docker network inspect 容器id

#查看端口的绑定情况
iptables -t nat -L -n
```

#### 配置redis主从

原理步骤，可以通过redis的log日志查看：

1.在【从】节点设置slaveof的时候保存主节点信息

2.【从】节点会通过定时任务不断请求【主】节点建立socket连接

3.【从】节点会发送ping命令，ping不通的话也会通过定时任务不断请求

4.权限验证，验证密码等

5.同步数据集，这里第一次是全量复制，主节点压力会非常大，可能影响正常业务

6.命令持续复制，增量复制。如果存在多个【从】节点，数据同步是主节点依次向每个【从】节点推送数据，而不是从节点去获取，并且是一个一个推，而不是同时推

```bash
#1.通过docker命令分别运行redis容器
docker run -it  --name  redis-master  --net mynetwork  -p 6380:6379  --ip 192.168.1.2  redis 
docker run -it  --name  redis-slave  --net mynetwork  -p 6381:6379   --ip 192.168.1.3  redis 

#2.在【从机】上配置【主机】
redis-cli -a 123456
slaveof 192.168.1.2:6379

#3.配置了以后【主从】都需要重启
docker restart redis-master
docker restart redis-slave

#4.重启之后再次进入【从机】查看redis连接状态
redis-cli -a 123456
info replication
这是【从】节点查看的主要参数
  -role								//角色
  -master_host				//【主机】ip
  -master_port
  -master_link_status //【主机】连接状态，up为正常
  
#5.【主】节点查看
info replication
这是【主】节点查看的主要参数
  -role								//角色
  -connected_slaves		//连接的【从】机数量
  -slave0：ip=192.168.0.3,port=6379,state=online,offset=46546,lag=0		//【从】机的连接状态				          				# state=online 为正常
  			# offset=46546 从节点偏移量
  -master_repl_offset	//主节点偏移量，主要用于记录同步推送时的偏移位置

#6.因为【从】节点只能读取，无法设置变量，则在【主】节点设置一个
set test 1111
#【从】节点查看是否成功
keys *
```

> redis.conf需要注意的设置
>
> 如果主redis没有设置密码，就需要关闭他的保护模式：protected-mode no

从节点开启主从复制，有3种方式：

> （1）配置文件（一般不推荐）
> 在从服务器的配置文件中设置：slaveof <masterip> <masterport>
> （2）启动命令（推荐）
> redis-server启动命令后加入    --slaveof <masterip> <masterport>
> （3）客户端命令
> Redis服务器启动后，直接通过客户端执行命令：slaveof <masterip> <masterport>
> 通过 info replication 命令可以看到复制的一些参数信息

#### 全量复制过程

> **runid(服务器运行ID)：**每个Redis节点(无论主从)，在启动时都会自动生成一个随机ID(每次启动都不一样)，由40个随机的十六进制字符组成；runid用来唯一识别一个Redis节点。  通过 info server 命令，可以查看节点的runid
>
> **复制积压缓冲区：**主节点在复制的时候也需要向外提供服务，这段时间的写命令无法同步，所以需要暂存到复制积压缓冲区，缓冲区默认大小为1MB，由于复制积压缓冲区定长且先进先出，所以它保存的是主节点最近执行的写命令，时间较早的写命令会被挤出缓冲区。

1、Redis【从】节点内部会发出一个同步命令，刚开始是Psync 命令，Psync ? -1表示要求 master 主机同步数据
2、【主】机会向【从】机发送 runid 和 offset，因为 slave 并没有对应的 offset，所以是全量复制
3、从机 slave 会保存主机master 的基本信息 save masterInfo
4、主节点收到全量复制的命令后，执行bgsave（异步执行），在后台生成RDB文件（快照，4.0之后不需要这个文件也能推送），并使用一个复制积压缓冲区，记录从现在开始执行的所有写命令。
5、主机send RDB 发送 RDB 文件给从机
6、RDB 文件发送完成后，发送缓冲区数据
7、刷新旧的数据，从节点在载入主节点的数据之前要先将所有老数据清除
8、加载RDB 文件将数据库状态更新至主节点执行bgsave时（快照）的数据库状态和缓冲区数据的加载。

> 全量复制开销，主要有以下几项。
> bgsave 时间
> RDB 文件网络传输时间 
> 从节点清空数据的时间 
> 从节点加载 RDB 的时间

#### 部分复制过程

> Redis 2.8 以后出现的，之所以要加入部分复制，是因为全量复制会产生很多问题，比如像上面的时间开销大、无法隔离等问题，  Redis 希望能够在 master 出现抖动（断开连接）的时候，可以有一些机制将复制的损失降低到最低。

1、如果网络抖动（连接断开connection lost）
2、主机master 还是会写 replbackbuffer（复制缓冲区）
3、从机slave 会继续尝试连接主机
4、从机slave 会把自己当前 runid 和偏移量传输给主机 master，并且执行 pysnc 命令同步
5、如果 master 发现你的偏移量是在缓冲区的范围内，就会返回 continue 命令
6、同步了 offset 的部分数据，所以部分复制的基础就是偏移量 offset。

#### redis如何决定是全量复制还是部分复制？

> 从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制:
> 如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；
> 如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。

#### 设置复制积压缓冲区大小
> 为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)来设置。
> 例如：如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。
>
> repl-backlog-size 在redis的配置文件中，默认为 1mb，不过一般够用了。注意这个是网络断开的情况下才有用，因为从节点的runid变了