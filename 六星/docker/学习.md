一、

#### Centos 安装docker

```bash
#1、更新update到最新的版本  
yum  update
#2、卸载老版本docker
yum  remove docker  docker-common docker-selinux  docker-engine
#3、安装需要的软件包
yum install -y yum-utils  device-mapper-persistent-data lvm2
#4、设置yum源
yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
#5、查看docker版本
yum list docker-ce --showduplicates|sort -r  
#6、安装docker
yum  install  docker-ce-18.03.1.ce -y
#7、启动docker
systemctl start docker
#查看状态
systemctl status docker
#8、加入开机自启
systemctl enable docker
#9、配置国内镜像
vi /etc/docker/daemon.json 
{
"registry-mirrors": ["http://hub-mirror.c.163.com"]
}
#10.更换docker国内源需要重启
systemctl restart docker
```

#### docker常用指令

```bash
#1.启动
docker start 容器名
#2.删除
docker rm 容器名
#3.停止/删除所有容器
docker stop  $(docker ps -a -q)
docker rm  $(docker ps -a -q) 
#删除镜像，i代表image
docker rmi  $(docker ps -a -q) 

#4.根据Dockerfile构建镜像
docker build -t 名称 .
-t ，--tag list  #构建后的镜像名称
-f， --file string #指定Dockerfiile文件位置
示例：
1，docker build . 
2，docker build -t redis:v1 .
3，docker build -t redis:v2 -f /path/Dockerfile /path
一般常用第2种方式构建，我们在构建时都会切换到Dockerfile文件的目录下进行构建，所以不需要指定-f参
#查看构建镜像历史记录，方便查错
docker history 镜像ID
#查看构建容器日志，方便查错
docker logs 容器id
#Dockerfile调错：有一种情况是无法查看日志，一构建就退出，找不到原因，那就先把dockerfile文件中的CMD命令注释掉，docker run 构建的命令最后加上bash,直接进入容器运行应用启动命令

#5、使用此docker镜像 创建容器
docker run -itd --name  redis-master  --net mynetwork  -p 6380:6379  --ip 192.168.1.2  redis 
-d:     后台运行容器，并返回容器ID；  
-i:     以交互模式运行容器，通常与 -t 同时使用；
-p:     端口映射，格式为：主机(宿主)端口:容器端口
-t:     为容器重新分配一个伪输入终端，通常与 -i 同时使用；
-V:     为容器挂载目录，比如 /usr/docker/data:/data 前者为数宿主机目录后者为容器内目录
--ip:   为容器制定一个固定的ip 
--net:  指定网络模式

#6.查看容器信息
docker inspect 容器名

#7.进入容器
docker exec -it 容器 bash

#8.重启容器，两种方式
#exec代表在容器在执行一个命令
docker restart nginx
docker exec nginx nginx -s load

#导出容器
docker export 已存在的容器id/name > 文件名.tar
docker save 已存在的容器id/name > 文件名.tar
#导入容器
docker import 文件名.tar 容器自定义name
docker load < 文件名.tar
```

> 注意他们与save\load的区别，两对命令都能导入导出，save方式导出的文件比export方式导出的文件大，因为save方式保存了镜像的历史和层，使其可以回滚到之前的历史层。反观export方式，在导出过程中丢失所有的历史，导致其不可以层回滚，导出的文件会小一些。

#### 容器网络

```bash
#Docker安装后，默认会创建三种网络类型，查看所有：
docker network ls

#默认情况下启动Docker容器都是使用桥接方式bridge，每次Docker容器重启时，会按照顺序获取对应的IP地址，这个就导致重启下，Docker的IP地址就变了。所以我们需要创建自定义网络并指定网段：192.168.1.0/24，命名为mynetwork
docker network create --subnet=192.168.1.0/24 mynetwork
docker network ls

#查看自定义网络信息
docker network inspect mynetwork
#查看某个容器的网络信息
docker network inspect 容器id

#查看端口的绑定情况
iptables -t nat -L -n
```

#### 配置redis主从

原理步骤，可以通过redis的log日志查看：

1.在【从】节点设置slaveof的时候保存主节点信息

2.【从】节点会通过定时任务不断请求【主】节点建立socket连接

3.【从】节点会发送ping命令，ping不通的话也会通过定时任务不断请求

4.权限验证，验证密码等

5.同步数据集，这里第一次是全量复制，主节点压力会非常大，可能影响正常业务

6.命令持续复制，增量复制。如果存在多个【从】节点，数据同步是主节点依次向每个【从】节点推送数据，而不是从节点去获取，并且是一个一个推，而不是同时推

```bash
#1.通过docker命令分别运行redis容器
docker run -it  --name  redis-master  --net mynetwork  -p 6380:6379  --ip 192.168.1.2 -v /home/redis/master:/usr/src/redis redis 
docker run -it  --name  redis-slave  --net mynetwork  -p 6381:6379   --ip 192.168.1.3 -v /home/redis/slave:/usr/src/redis redis 

docker run -it --name redis-master -p 6380:6379 -v /home/redis/master:/usr/src/redis redis

#2.在【从机】上连接【主机】
#如果【主】redis没有设置密码，需要关闭它配置文件中的保护模式：protected-mode no（protected-mode代表禁止公网访问redis）
redis-cli -a 123456
SLAVEOF 192.168.1.2 6379

#3.重启之后再次进入【从机】查看redis连接状态
redis-cli -a 123456
info replication
这是【从】节点查看的主要参数
  -role								//角色
  -master_host				//【主机】ip
  -master_port
  -master_link_status //【主机】连接状态，up为正常
  
#4.【主】节点查看
info replication
这是【主】节点查看的主要参数
  -role								//角色
  -connected_slaves		//连接的【从】机数量
  -slave0：ip=192.168.0.3,port=6379,state=online,offset=46546,lag=0		//【从】机的连接状态				          				# state=online 为正常
  			# offset=46546 从节点偏移量
  -master_repl_offset	//主节点偏移量，主要用于记录同步推送时的偏移位置

#5.因为【从】节点只能读取，无法设置变量，则在【主】节点设置一个
set test 1111
#【从】节点查看是否成功
keys *

<<<<<<< Updated upstream


#### 主从配置参数参考

```bash
###########  从库配置文件  ##############
#设置该数据库为其他数据库的从数据库 
slaveof <masterip> <masterport>
#主从复制中，设置连接master服务器的密码（前提master启用了认证） 
masterauth <master-password>
slave-serve-stale-data yes

# 当从库同主库失去连接或者复制正在进行，从库有两种运行方式：
# 1) 如果slave-serve-stale-data设置为yes(默认设置)，从库会继续相应客户端的请求
# 2) 如果slave-serve-stale-data设置为no，除了INFO和SLAVOF命令之外的任何请求都会返回一个错误"SYNC with master in progress" 

#当主库发生宕机时候，哨兵会选择优先级最高的一个称为主库，从库优先级配置默认100，数值越小优先级越高
slave-priority 100
#从节点是否只读；默认yes只读，为了保持数据一致性，应保持默认 
slave-read-only yes


########  主库配置文件  ##############
#在slave和master同步后（发送psync/sync），后续的同步是否设置成TCP_NODELAY假如设置成yes，则redis会合并小的TCP包从而节省带宽，但会增加 同步延迟（40ms），造成master与slave数据不一致假如设置成no，则redis master会立即发送同步数据，没有延迟
#前者关注性能，后者关注一致性 
repl-disable-tcp-nodelay no
#从库会按照一个时间间隔向主库发送PING命令来判断主服务器是否在线，默认是10秒 
repl-ping-slave-period 10

#复制积压缓冲区大小设置 
repl-backlog-size 1mb

#master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。单位为秒。 
repl-backlog-ttl 3600

#redis提供了可以让master停止写入的方式，如果配置了min-slaves-to-write，健康的slave的个数小于N，mater就禁止写入。master最少得有多少个健康的slave存活才能执行写命令。这个配置虽然不能保证N个slave都一定能接收到master的写操作，但是能避免没有足够健康的slave的时候，master不能写入来避免数据丢失。设置为0是关闭该功能。
min-slaves-to-write 3 
min-slaves-max-lag 10
```

#### 各种主从问题请参考docker第4节笔记

> redis.conf需要注意的设置
>
> 如果主redis没有设置密码，就需要关闭他的保护模式：protected-mode no
=======
#查看runid
 info server
 
# 用第一个【从机1】的配置增加一台【从机2】，为什么【从机2】没有和【主机】建立连接就有了数据？
# 因为【从机2】加载了【从机1】data目录下的数据文件dump.rdb
```
>>>>>>> Stashed changes

从节点开启主从复制，有3种方式：

> （1）配置文件（一般不推荐）
> 在从服务器的配置文件中设置：slaveof <masterip> <masterport>
> （2）启动命令（推荐）
> redis-server启动命令后加入    --slaveof <masterip> <masterport>
> （3）客户端命令
> Redis服务器启动后，直接通过客户端执行命令：slaveof <masterip> <masterport>
> 通过 info replication 命令可以看到复制的一些参数信息

#### 全量复制过程

> **runid(服务器运行ID)：**每个Redis节点(无论主从)，在启动时都会自动生成一个随机ID(每次启动都不一样)，由40个随机的十六进制字符组成；runid用来唯一识别一个Redis节点。  通过 info server 命令，可以查看节点的runid
>
> **复制积压缓冲区：**主节点在复制的时候也需要向外提供服务，这段时间的写命令无法同步，所以需要暂存到复制积压缓冲区，缓冲区默认大小为1MB，由于复制积压缓冲区定长且先进先出，所以它保存的是主节点最近执行的写命令，时间较早的写命令会被挤出缓冲区。

1、Redis【从】节点内部会发出一个同步命令，刚开始是Psync 命令，Psync ? -1表示要求 master 主机同步数据
2、【主】机会向【从】机发送 runid 和 offset，因为 slave 并没有对应的 offset，所以是全量复制
3、从机 slave 会保存主机master 的基本信息 save masterInfo
4、主节点收到全量复制的命令后，执行bgsave（异步执行），在后台生成RDB文件（快照，4.0之后不需要这个文件也能推送），并使用一个复制积压缓冲区，记录从现在开始执行的所有写命令。
5、主机send RDB 发送 RDB 文件给从机
6、RDB 文件发送完成后，发送缓冲区数据
7、刷新旧的数据，从节点在载入主节点的数据之前要先将所有老数据清除
8、加载RDB 文件将数据库状态更新至主节点执行bgsave时（快照）的数据库状态和缓冲区数据的加载。

> 全量复制开销，主要有以下几项。
> bgsave 时间
> RDB 文件网络传输时间 
> 从节点清空数据的时间 
> 从节点加载 RDB 的时间

#### 部分复制过程

> Redis 2.8 以后出现的，之所以要加入部分复制，是因为全量复制会产生很多问题，比如像上面的时间开销大、无法隔离等问题，  Redis 希望能够在 master 出现抖动（断开连接）的时候，可以有一些机制将复制的损失降低到最低。

1、如果网络抖动（连接断开connection lost）
2、主机master 还是会写 replbackbuffer（复制缓冲区）
3、从机slave 会继续尝试连接主机
4、从机slave 会把自己当前 runid 和偏移量传输给主机 master，并且执行 pysnc 命令同步
5、如果 master 发现你的偏移量是在缓冲区的范围内，就会返回 continue 命令
6、同步了 offset 的部分数据，所以部分复制的基础就是偏移量 offset。

#### redis如何决定是全量复制还是部分复制？

> 从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制:
> 如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；
> 如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。

#### 设置复制积压缓冲区大小（【主机】）
> 为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)来设置。
> 例如：如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。
>
> repl-backlog-size 在redis的配置文件中，默认为 1mb，不过一般够用了。注意这个是网络断开的情况下才有用，因为从节点的runid变了



#### [Predis](https://packagist.org/search/?query=predis)简单使用

```php
#首先需要安装
composer require predis/predis

#使用
require 'vendor/autoload.php';
include "config.php";

$redis=new Predis\Client([
  'tcp://118.24.109.254:6380?alias=master',
  'tcp://118.24.109.254:6381?alias=slave-01'
],[
    'replication'=>true,
    'parameters' => [
        'password' => '123456',
  ]
]);
echo $redis->set('test',123);
var_dump($redis->get('test'));
```

#### 五、持久化处理（看笔记即可）

##### 持久化的选择

1.如果Redis只用作DB层数据的cache，则完全不需要持久化处理

2.如果可以接受十多分钟的数据丢失，可以选择RDB；如果对数据的安全性要求较高，则可以使用AOF

3.对于主从环境，主服务器可以完全关闭持久化，从服务器可以开启AOF，并使用定时任务对持久化文件进行备份，然后关闭AOF的自动重写（因为占用资源太大），然后添加定时任务，手动在每天Redis空闲时调用bgrewriteaof命令。

4.应尽量避免“自动拉起机制”和“不做持久化”同时出现。因为那样会清空内存中的数据，从节点同步之后也会清空。

如果做了持久化，主节点就可以自动重启。

5.异地灾备，一般来说，由于RDB文件文件小、恢复快，因此灾难恢复常用RDB文件；异地备份的频率最好不要低于 
一天一次。

#### 七、docker-compose

##### <font face="微软雅黑"  color = #42A5F5 > Curl方式下载新的版本 </font>
```bash
#下载，如果太慢可以去 http://get.daocloud.io/ 下载
curl -L https://github.com/docker/compose/releases/download/1.2.0/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose  

#修改权限
chmod +x /usr/local/bin/docker-compose

#安装完成后可以查看版本
docker-compose --version

#编写docker-compose.yaml文件并构建
docker-compose up -d

#停止所有
docker-compose stop

#删除所有，需要再确认一下
docker-compose rm

#查看所有
docker-compose ps
```

#### 8.哨兵（适用于一主多从）

```bash
#连接哨兵
redis-cli -p 26379

#进入redis终端查看信息
info

#redis配置文件需要注意的地方
#最后的2代表票数超过所有节点的一半（n/2+1）就开始投票
sentinel monitor mymaster maater-1 6379 2
sentinel auth-pass mymaster 123456

#哨兵日志
cat /usr/src/redis/sentinel.log
```





















扩展参考

[Hub Docker](https://hub.docker.com/search?q=mysql)